;;;; This file is part of algebolic. Copyright (C) 2014-, Jony Hudson.
;;;;
;;;; algebolic is licenced to you under the MIT licence. See the file LICENCE.txt for full details.

(ns algebolic.expression.genetics
  "Core genetic operation on expressions. Includes functions for creating expressions."
  (:require [algebolic.expression.core :as expression]
            [algebolic.expression.tree :as tree]))

(defn random-full-tree
  "Generates a tree filled to the given depth from the given functions and terminals. The
  functions and terminals should be supplied in the format shown in algebolic.core."
  [functions terminals depth]
  (if (= depth 0)
    ;; note the double brackets on the next line. This is because `terminals` is a list of functions
    ;; that generate terminals.
    ((rand-nth terminals))
    (let [func (rand-nth functions)
          leaves (repeatedly (:arity func) #(random-full-tree functions terminals (- depth 1)))]
      (conj leaves (:name func)))))

(defn simple-mutation
  "Replaces a randomly selected part of the expression with a new tree generated by calling the
  given function. The subtree to be replaced is selected from the nodes (terminal and function)
  with uniform probability."
  [new-tree-func expr]
  (let [size (tree/count-nodes expr)
        target (rand-int size)]
    (tree/tree-replace expr target (new-tree-func))))

(defn random-tree-mutation
  "Replaces part of the given expression with a random tree, generated from the given functions and
  terminals, with the given depth"
  [functions terminals depth expr]
  (simple-mutation #(random-full-tree functions terminals depth) expr))

(defn simple-crossover
  "Randomly selects a crossover point in each of the two given trees, and switches the subtrees
  at these points. The crossover points are selected from the terminal and function nodes with
  uniform probability."
  [expr1 expr2]
  (let [size1 (tree/count-nodes expr1)
        target1 (rand-int size1)
        size2 (tree/count-nodes expr2)
        target2 (rand-int size2)
        subtree1 (tree/sub-tree expr1 target1)
        subtree2 (tree/sub-tree expr2 target2)]
    [(tree/tree-replace expr1 target1 subtree2) (tree/tree-replace expr2 target2 subtree1)]))

(defn make-initial-population
  "Make an intial population of n expressions, with depths up to and including max-depth. You can
  use this if you are just evolving expressions."
  [functions terminals n max-depth]
  (repeatedly n (fn [] (random-full-tree functions terminals (+ 1 (rand-int (- max-depth 1)))))))